#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define SIZE 13
//#define RANGE 100
//#define SIZE 10
//int a = 3;
//int price[5];
//printf("%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n", sizeof(a), sizeof(int), sizeof(long), sizeof(long long), sizeof(char), sizeof(double), sizeof("programming"), sizeof("qwer"), sizeof(price), sizeof(price[0]));


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
	/*int prime[RANGE + 1]; //매우 효율적인
	for (int i = 0; i <= RANGE; i++) {
		prime[i] = 1;
	}
	for (int i = 2; i <= RANGE; i++) {
		if (prime[i]) {
			for (int j = i * 2; j <= RANGE; j += i) {
				prime[j] = 0;
			}
		}
	}
	printf("%d까지의 소수 목록\n", RANGE);
	for (int i = 2; i <= RANGE; i++) {
		if (prime[i]) {
			printf("%d ", i);
		}
	}*/

//"""sizeof는 파이썬의 len()과 유사하다!!!!!!!!!!!!!!!!!!!!!!"""

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
	//	int list[SIZE] = { 10,20,30,40,50,60,70,80,90,100 };
	//	int key, i;
	//	int found = 0;
	//	printf("찾는 값 입력: ");
	//	scanf("%d", &key);
	//
	//	for (i = 0; i < SIZE; i++) { // 순차탐색
	//		if (list[i] == key) {
	//			found = 1;
	//			break;
	//		}
	//	}
	//	if (found == 1) 
	//		printf("찾는 값의 인덱스 = %d\n", i);
	//	else
	//		printf("찾는 값이 없습니다.\n");



//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//int key, list[] = { 1,25,38,39,55,64,97,180,190,200 };
	//int found = 0;
	//int index = -1;
	//int low = 0, high = sizeof(list) / sizeof(int) - 1, middle;
	//printf("찾는 값 입력: ");
	//scanf("%d", &key);
	//while (low <= high) {
	//	middle = (low + high) / 2;
	//	if (key == list[middle]) { //찾음
	//		index = middle; //찾은 위치(첨자) 기록
	//		found = 1;
	//		break;
	//	}
	//	else if (key > list[middle]) {
	//		low = middle + 1;
	//	}
	//	else {
	//		high = middle - 1;
	//	}
	//}
	//if (found) 
	//	printf("有\n");
	//else
	//	printf("無\n");

	//if (found == 1){
	//	printf("찾는 값의 인덱스 = %d\n", index);
	//}
	//else
	//	printf("찾는 값이 없습니다.\n");


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
//정렬 방식- 버블 정렬-오름차순
//	int i, k, list[SIZE] = { 1,2,3,2312,222,333,222,33,12,342,54435,2,445 };
//	for (k = 0; k < SIZE - 1; k++) { //SIZE-1 등까지 선정
//		for (i = 0; i < SIZE - 1 - k; i++) {// 순위가 결정된 원소 제외
//			if (list[i] > list[i + 1]) { //크기 순이 아니면
//				int tmp = list[i];       // 서로 교환 (앞 뒤 자리바꿈)
//				list[i] = list[i + 1];
//				list[i + 1] = tmp;
//			}
//		}
//	}
//	for (i = 0; i < SIZE; i++) { // 정렬 결과 출력
//		printf("%d ", list[i]);
//	}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
//정렬 방식- 버블 정렬-내림차순
	//int i, k, list[SIZE] = { 1,2,3,2312,222,333,222,33,12,342,54435,2,445 };
	//for (k = 0; k < SIZE - 1; k++) { //SIZE-1 등까지 선정
	//	for (i = 0; i < SIZE - 1 - k; i++) {// 순위가 결정된 원소 제외
	//		if (list[i] < list[i + 1]) { //크기 순이 아니면
	//			int tmp = list[i];       // 서로 교환 (앞 뒤 자리바꿈)
	//			list[i] = list[i + 1];
	//			list[i + 1] = tmp;
	//		}
	//	}
	//}
	//for (i = 0; i < SIZE; i++) { // 정렬 결과 출력
	//	printf("%d ", list[i]);
	//}

	
	
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 선택 정렬
int main() {
	int i, k, indexOFMin;
	int list[SIZE]= { 1,2,3,2312,222,333,222,33,12,342,54435,2,445 };

	for (k = 0; k < SIZE - 1; k++) {			 // 0등(1등)부터 12등(13등)까지
												 // 남은 요소들 중 가장 앞의 것이 작다고 가정
		indexOFMin = k;
		for (i =  k + 1; i < SIZE; i++) {
			if (list[i] < list[indexOFMin]) {	 // 더 작은 것을 발견하면 기록
				indexOFMin = i;
			}
		}
		if (k!=indexOFMin) {					 // 남은 요소들 중 가장 작은 값 자리에 오도록 자리바꿈
			int tmp = list[k];					 // 남은 요소들 중 가장 작은 값이 앞에 오도록 자리바꿈
			list[k] = list[indexOFMin];
			list[indexOFMin] = tmp;
		}
	}
	for (i = 0; i < SIZE; i++) {				 // 정렬결과 출력
		printf("%d ", list[i]);
	}
}

												 // 시험에는 버블정렬이든 선택정렬이든 능숙하게 사용하도록 준비하자
